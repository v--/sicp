#lang sicp

; Exercise 1.14
;
; Draw the tree illustrating the process generated by the count-change procedure of section 1.2.2
; in making change for 11 cents. What are the orders of growth of the space and number of steps
; used by this process as the amount to be changed increases?

; Solution
; Original definitions

(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

; The full call tree is
;
; cc(11, 5) = 4
; ├──cc(11, 4) = 4
; │  ├──cc(11, 3) = 4
; │  │  ├──cc(11, 2) = 3
; │  │  │  ├──cc(11, 1) = 1
; │  │  │  │  ├──cc(11, 0) = 0
; │  │  │  │  └──cc(10, 1) = 1
; │  │  │  │     ├──cc(10, 0) = 0
; │  │  │  │     └──cc(9, 1) = 1
; │  │  │  │        ├──cc(9, 0) = 0
; │  │  │  │        └──cc(8, 1) = 1
; │  │  │  │           ├──cc(8, 0) = 0
; │  │  │  │           └──cc(7, 1) = 1
; │  │  │  │              ├──cc(7, 0) = 0
; │  │  │  │              └──cc(6, 1) = 1
; │  │  │  │                 ├──cc(6, 0) = 0
; │  │  │  │                 └──cc(5, 1) = 1
; │  │  │  │                    ├──cc(5, 0) = 0
; │  │  │  │                    └──cc(4, 1) = 1
; │  │  │  │                       ├──cc(4, 0) = 0
; │  │  │  │                       └──cc(3, 1) = 1
; │  │  │  │                          ├──cc(3, 0) = 0
; │  │  │  │                          └──cc(2, 1) = 1
; │  │  │  │                             ├──cc(2, 0) = 0
; │  │  │  │                             └──cc(1, 1) = 1
; │  │  │  │                                ├──cc(1, 0) = 0
; │  │  │  │                                └──cc(0, 1) = 1
; │  │  │  │
; │  │  │  └──cc(6, 2) = 2
; │  │  │     ├──cc(6, 1) = 1
; │  │  │     │  ├──cc(6, 0) = 0
; │  │  │     │  └──cc(5, 1) = 1
; │  │  │     │     ├──cc(5, 0) = 0
; │  │  │     │     └──cc(4, 1) = 1
; │  │  │     │        ├──cc(4, 0) = 0
; │  │  │     │        └──cc(3, 1) = 1
; │  │  │     │           ├──cc(3, 0) = 0
; │  │  │     │           └──cc(2, 1) = 1
; │  │  │     │              ├──cc(2, 0) = 0
; │  │  │     │              └──cc(1, 1) = 1
; │  │  │     │                 ├──cc(1, 0) = 0
; │  │  │     │                 └──cc(0, 1) = 1
; │  │  │     │
; │  │  │     └──cc(1, 2) = 1
; │  │  │        ├──cc(1, 1) = 1
; │  │  │        │  ├──cc(1, 0) = 0
; │  │  │        │  └──cc(0, 1) = 1
; │  │  │        │
; │  │  │        └──cc(-4, 2) = 0
; │  │  │
; │  │  └──cc(1, 3) = 1
; │  │     ├──cc(1, 2) = 1
; │  │     │  ├──cc(1, 1) = 1
; │  │     │  │  ├──cc(1, 0) = 0
; │  │     │  │  └──cc(0, 1) = 1
; │  │     │  │
; │  │     │  └──cc(-4, 2) = 0
; │  │     │
; │  │     └──cc(-9, 3) = 0
; │  │
; │  └──cc(-14, 4) = 0
; │
; └──cc(-39, 5) = 0
;
; Which yields 4 possible coin combinations.

(#%require rackunit)

(check-equal? (count-change 11) 4)

; T(n, k) is the time complexity for count-change for coin kinds k that was inferred from the call tree.
;
;   T(n, k) = {
;     2 * n + 1,                                             if k == 1
;     sum_(i = 0)^m(n, k) (T(n - i * d_k, k - 1) + 1) + 1,   if k > 1
;   },
;
; where d_k is the first denominator for coin kinds k and m is
;
;   m(n, k) = {
;     0,                    if n = 0
;     floor(n / d_k) - 1,   if n != 0 and d_k divides n
;     floor(n / d_k),       otherwise
;   }.
;
; Removing constant terms and multipliers yields
;
;   T(n, k) ~ {
;     n,                 if k == 1
;     n * T(n, k - 1),   if k > 1
;   },
;
; which shows that T(n, k) belongs to Omega(n^k).
;
; An empirical proof that T(n, k) is indeed the time complexity function for the count-change procedure
; is given below (with unit tests).

(define (count-change-calls amount kinds-of-coins)
  (+ 1 (cc-count-calls amount kinds-of-coins)))

(define (cc-count-calls amount kinds-of-coins)
  (if (or (<= amount 0) (= kinds-of-coins 0))
      0
      (+ 2
         (cc-count-calls amount
                         (- kinds-of-coins 1))
         (cc-count-calls (- amount
                            (first-denomination kinds-of-coins))
                         kinds-of-coins))))

(define (sum list)
  (if (null? list)
      0
      (+ (car list) (sum (cdr list)))))

(define (integer-list start end)
  (cond [(> start end) nil]
        [(= start end) (cons start nil)]
        [else (cons start (integer-list (inc start) end))]))

(define (divides x y)
  (= 0 (remainder x y)))

(define (calculate-call-count n k)
  (let* ([denomination (first-denomination k)]
         [limit (floor (/ n denomination))]
         [refined-limit (cond [(= n 0) 0]
                              [(divides n denomination) (- limit 1)]
                              [else limit])]

         [reducer (lambda (i)
                    (+ (calculate-call-count (- n (* i denomination))
                                             (- k 1))
                       1))])

    (if (= k 1)
        (+ 1 (* 2 n))
        (+ 1 (sum (map reducer (integer-list 0 refined-limit)))))))

(check-equal? (count-change-calls 6 1) (calculate-call-count 6 1))
(check-equal? (count-change-calls 6 2) (calculate-call-count 6 2))
(check-equal? (count-change-calls 6 3) (calculate-call-count 6 3))
(check-equal? (count-change-calls 10 3) (calculate-call-count 10 3))
(check-equal? (count-change-calls 10 4) (calculate-call-count 10 4))
(check-equal? (count-change-calls 15 4) (calculate-call-count 15 4))
(check-equal? (count-change-calls 15 5) (calculate-call-count 15 5))

; The space complexity is linear (again, inferred from the call tree):
;   S(n, k) = 2 * n + k ~ Omega(n + k).
