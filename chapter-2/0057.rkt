#lang sicp

(require (only-in chapter-2/0056 variable? same-variable? sum? addend product? multiplier =number?))

; Exercise 2.57
;
; Extend the differentiation program to handle sums and products of arbitrary numbers of
; (two or more) terms. Then the last example above could be expressed as
;   (deriv '(* x y (+ x 3)) 'x)
; Try to do this by changing only the representation for sums and products, without changing the deriv procedure at all.
; For example, the addend of a sum would be the first term, and the augend would be the sum of the rest of the terms.

; Solution
; Original definitions

(define (deriv-factory make-sum sum? addend augend
                       make-product product? multiplier multiplicand)
  (define (deriv exp var)
    (cond [(number? exp) 0]
          [(variable? exp)
           (if (same-variable? exp var) 1 0)]
          [(sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var))]
          [(product? exp)
           (make-sum
             (make-product (multiplier exp)
                           (deriv (multiplicand exp) var))
             (make-product (deriv (multiplier exp) var)
                           (multiplicand exp)))]
          [else
           (error "unknown expression type -- DERIV" exp)]))

  deriv)

; Operator and selector factory
(define (make-operator symbol numeric-operation numeric-identity numeric-absorber)
  (define (operator . terms)
    (let ([numeric-part (foldr numeric-operation numeric-identity (filter number? terms))]
          [symbolic-part (filter (lambda (x) (not (number? x))) terms)])
      (cond [(equal? numeric-absorber numeric-part) numeric-absorber]
            [(null? symbolic-part) numeric-part]
            [(and (= numeric-part numeric-identity) (null? (cdr symbolic-part))) (car symbolic-part)]
            [(= numeric-part numeric-identity) (cons symbol symbolic-part)]
            [else (cons symbol (cons numeric-part symbolic-part))])))

  operator)

(define (make-rest-selector symbol)
  (define (rest-selector exp)
    (let ([rest (cddr exp)])
      (if (null? (cdr rest))
          (car rest)
          (cons symbol rest))))

  rest-selector)

; Concrete operations
(define make-sum (make-operator '+ + 0 null))
(define augend (make-rest-selector '+))

(define make-product (make-operator '* * 1 0))
(define multiplicand (make-rest-selector '*))

(define deriv (deriv-factory make-sum sum? addend augend
                             make-product product? multiplier multiplicand))

(provide deriv-factory make-operator make-sum make-product)

(module+ test
  (require rackunit)

  ; Only test make-sum, because make-product is generated by the same higher-order factory
  (check-equal? (make-sum)
                0)

  (check-equal? (make-sum 1)
                1)

  (check-equal? (make-sum 0 1)
                1)

  (check-equal? (make-sum 1 2 3)
                6)

  (check-equal? (make-sum 1 'x 3)
                '(+ 4 x))

  (check-equal? (make-sum 1 'x 'y 'z 't)
                '(+ 1 x y z t))

  ; Test rest selector
  (check-equal? (augend (make-sum 1 'x))
                'x)

  (check-equal? (augend (make-sum 1 'x 'y 'z 't))
                '(+ x y z t))

  ; Test if the original deriv procedure works with the new constructors and selectors
  (check-equal? (deriv '(* x y (+ x 3)) 'x)
                '(+ (* x y) (* y (+ x 3)))))
